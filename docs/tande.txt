-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/githubuser/tande#readme</a>
@package tande
@version 0.1.0.0

module Ast
data Op
Add :: Op
Sub :: Op
Mul :: Op
Div :: Op
type Pi = Integer
type Name = String
data Expr
Integer :: Integer -> Expr
Bool :: Bool -> Expr
Var :: Name -> Expr
Fn :: Pi -> Name -> Expr -> Expr
Fun :: Pi -> Name -> Name -> Expr -> Expr
App :: Expr -> Expr -> Expr
Let :: Name -> Expr -> Expr -> Expr
ITE :: Expr -> Expr -> Expr -> Expr
Oper :: Op -> Expr -> Expr -> Expr
Pair :: Pi -> Expr -> Expr -> Expr
PCase :: Expr -> Name -> Name -> Expr -> Expr
Cons :: Pi -> Expr -> Expr -> Expr
Nil :: Pi -> Expr
LCase :: Expr -> Name -> Name -> Expr -> Expr -> Expr
bin :: Name -> Expr -> Expr -> Expr
type LabelM = State Integer
assignLabels :: Expr -> Expr
instance GHC.Classes.Eq Ast.Op
instance GHC.Classes.Eq Ast.Expr

module Parsing
parseExpr :: String -> Expr
pExpr :: Parser Expr
pIdent :: Parser Name
pConst :: Parser Name
pOper :: Parser Name
pUnderscore :: Parser Char
pFoldr2Sep :: IsParser p => (a -> b -> b, b) -> p a1 -> p a -> p b
pList2Sep :: IsParser p => p a1 -> p a -> p [a]

module Show
showLabel :: Integer -> ShowS
indent :: ShowS -> ShowS
instance GHC.Show.Show Ast.Expr
instance GHC.Show.Show Ast.Op

module Type
newtype FunId
FunId :: Pi -> FunId
type Ann = Set FunId
newtype AnnVar
AnnVar :: Integer -> AnnVar
newtype TyVar
TyVar :: Integer -> TyVar

-- | A <tt>Ty a</tt> represents a type with type annotations of type
--   <tt>a</tt>. A <tt>TArrow t1 a b t2</tt> is the <tt>t1 -&gt; t2</tt>
--   function type, which may have been defined at program points in
--   <tt>a</tt>, and may call functions defined at points in <tt>b</tt>.
--   The <tt>TPair</tt> and <tt>TList</tt> constructors respectively
--   represent pairs and lists, where the <tt>a</tt> annotation contains
--   all locations they could have been created.
data Ty a
FreeVar :: TyVar -> Ty a
TInt :: Ty a
TBool :: Ty a
TArrow :: Ty a -> a -> a -> Ty a -> Ty a
TPair :: a -> Ty a -> Ty a -> Ty a
TList :: Ty a -> a -> Ty a
data TyScheme a
SType :: Ty a -> TyScheme a
Forall :: TyVar -> TyScheme a -> TyScheme a
type TyEnv = Map Name (TyScheme AnnVar)

-- | A <tt>TySubst</tt> represents the composite substitution from type
--   variables to types, and annotation variables to annotation variables.
data TySubst
TySubst :: Map TyVar (Ty AnnVar) -> Map AnnVar AnnVar -> TySubst

-- | A <tt>Constr</tt> represents a relation between an annotation variable
--   and either another variable, or a program point. <tt>Ni a pi</tt>
--   expresses that <tt>pi</tt> is in <tt>a</tt>, and <tt>Super a b</tt>
--   indicates that <tt>a</tt> contains <tt>b</tt>.
data Constr
Ni :: AnnVar -> FunId -> Constr
Super :: AnnVar -> AnnVar -> Constr
type Constrs = Set Constr

-- | Infer the type and annotation of a given (top-level) expression.
typeOf :: Expr -> (TyScheme Ann, Ann)

-- | Run <tt>ctaW</tt> on an expression.
ctaW' :: Expr -> (Ty AnnVar, AnnVar, TySubst, Constrs)

-- | <tt>ctaW</tt> implements algorithm W adapted to Call Tracking
--   Analysis.
ctaW :: TyEnv -> Expr -> State Integer (Ty AnnVar, AnnVar, TySubst, Constrs)

-- | Unify the subtypes of the argument types.
subUnify :: Ty AnnVar -> Ty AnnVar -> State Integer (TySubst, Ty AnnVar, Constrs)

-- | Create a subtype of the given type.
subtype :: Ty AnnVar -> Variance -> State Integer (Ty AnnVar, Constrs)

-- | A <tt>Variance</tt> tracks the polarity of locations in types. For an
--   arrow <tt>t1 -&gt; t2</tt> in positive position, <tt>t1</tt> is
--   negative, and vice versa.
data Variance
Co :: Variance
Contra :: Variance
op :: Variance -> Variance

-- | If <tt>a</tt> and <tt>b</tt> occur in the same location in <tt>t1</tt>
--   and <tt>t2</tt> respectively, return the necessary constraint to
--   maintain <tt>t1 &lt;= t2</tt>. This means that if <tt>a</tt> is
--   covariant or positive, we return <tt>a &lt;= b</tt>, and <tt>b &lt;=
--   a</tt> if it is contravariant or negative.
variance :: Variance -> AnnVar -> AnnVar -> Constr

-- | Unify two types, returning the substition and unified type.
unify :: Ty AnnVar -> Ty AnnVar -> (TySubst, Ty AnnVar)

-- | Check whether the given type variable and type are unifiable. This
--   wrapper for <tt>chk'</tt> ensures that <tt>a</tt> unifies with
--   <tt>FreeVar a</tt>, while this would not unify after stripping of a
--   type constructor, which would create an infinite type.
chk :: TyVar -> Ty a -> TySubst -> TySubst

-- | Check whether the given type variable and type are unifiable. Note
--   that <tt>a</tt> cannot unify with <tt>FreeVar a</tt> here, since this
--   would indicate the overall type becomes infinite.
chk' :: TyVar -> Ty a -> TySubst -> TySubst

-- | Create a fresh type variable.
freshVar :: State Integer (Ty a)

-- | Create a fresh annotation variable.
freshAnnVar :: State Integer AnnVar

-- | For <tt>as</tt>, create an annotation variable <tt>a</tt> and the
--   constraints expressing that <tt>a</tt> contains the union of
--   <tt>as</tt>.
annUnion :: [AnnVar] -> State Integer (AnnVar, Constrs)

-- | <tt>annNi a pi</tt> inserts the constraint expressing that <tt>pi</tt>
--   is in <tt>a</tt>.
annNi :: AnnVar -> Pi -> Constrs -> Constrs

-- | Generalise and insert a variable into an environment.
genIn :: Name -> Ty AnnVar -> TyEnv -> TyEnv

-- | Instatiate a type scheme to a type by replacing all bound variables
--   with fresh ones.
cfaInstantiate :: TyScheme AnnVar -> State Integer (Ty AnnVar)

-- | Generalise a type to a type scheme by quantifying all variables which
--   appear freely in the type and are unbound in the environment.
generalise :: TyEnv -> Ty a -> TyScheme a
envFreeVars :: TyEnv -> Set TyVar
schemeFreeVars :: TyScheme a -> Set TyVar
freeVars :: Ty a -> Set TyVar

-- | <tt>Substitute a</tt> states that for each <tt>s :: TySubst</tt>,
--   there is a meaningful substitution function <tt>subst s :: a -&gt;
--   a</tt>. In particular <tt>subst</tt> should obey the identity laws
--   
--   <pre>
--   subst mempty = id
--   </pre>
--   
--   <pre>
--   subst (TySubst (M.singleton a (FreeVar a)) mempty) = id
--   </pre>
--   
--   <pre>
--   subst (TySubst mempty (M.singleton a a)) = id
--   </pre>
--   
--   and idempotence
--   
--   <pre>
--   subst a . subst a = subst a
--   </pre>
--   
--   (We could narrow down the description further with alpha-equivalence
--   lemmas (e.g. injective substitutions are bijections, and preserve
--   alpha-equivalence both ways), but this is left as an exercise to the
--   reader.)
class Substitute a
subst :: Substitute a => TySubst -> a -> a

-- | <tt>substitute x s</tt> is the base case for most substitutions,
--   replacing <tt>x</tt> with its substitution if it is in <tt>s</tt>, and
--   returning <tt>x</tt> otherwise.
substitute :: Ord a => a -> Map a a -> a

-- | Return the substitution and simplified constraint set, formed by
--   removing all cyclic components and substituting all variables in such
--   components to a representative.
simplify :: Constrs -> (TySubst, Constrs)

-- | Convert a set of constraints to the constraint graph, in which a
--   directed edge <tt>a-&gt;b</tt> indicates a subset relation <tt>a &lt;=
--   b</tt>.
toGraph :: Constrs -> [(AnnVar, AnnVar, [AnnVar])]

-- | Remove all constraint loops of the form <tt>Super a a</tt>.
deloop :: Constrs -> Constrs

-- | Greedily solve a set of constraints for the least solution. Loops when
--   the constraints contain a cyclic component.
solveConstraints :: Constrs -> AnnVar -> Ann
replaceAnnVar :: (AnnVar -> Ann) -> Ty AnnVar -> Ty Ann
instance GHC.Show.Show Type.FunId
instance GHC.Classes.Ord Type.FunId
instance GHC.Classes.Eq Type.FunId
instance GHC.Show.Show Type.AnnVar
instance GHC.Classes.Ord Type.AnnVar
instance GHC.Classes.Eq Type.AnnVar
instance GHC.Classes.Ord Type.TyVar
instance GHC.Show.Show Type.TyVar
instance GHC.Classes.Eq Type.TyVar
instance GHC.Show.Show a => GHC.Show.Show (Type.Ty a)
instance GHC.Show.Show a => GHC.Show.Show (Type.TyScheme a)
instance GHC.Show.Show Type.Constr
instance GHC.Classes.Ord Type.Constr
instance GHC.Classes.Eq Type.Constr
instance GHC.Classes.Eq Type.Variance
instance Type.Substitute (Type.Ty Type.AnnVar)
instance Type.Substitute (Type.TyScheme Type.AnnVar)
instance Type.Substitute Type.TyEnv
instance Type.Substitute Type.AnnVar
instance Type.Substitute Type.Constr
instance (GHC.Classes.Ord a, Type.Substitute a) => Type.Substitute (Data.Set.Internal.Set a)
instance GHC.Base.Semigroup Type.TySubst
instance GHC.Base.Monoid Type.TySubst

module Pretty
pretty :: Pretty a => a -> String

-- | The <tt>Pretty</tt> class implements pretty printing for annotated
--   types. These can be read as ordinary Haskell types with annotations.
--   The annotated type <tt>x :: a &amp; b</tt> indicates that evaluating
--   <tt>x</tt> may call all functions at program points in the set
--   <tt>b</tt>. In the arrow type <tt>f :: t1 -a;b-&gt;</tt>, the
--   <tt>a</tt> annotation is the set of locations <tt>f</tt> may have been
--   defined, while <tt>b</tt> is the set of functions that may be called
--   when applying <tt>f</tt>. The annotation <tt>a</tt> in the tuple type
--   <tt>pair a(t1, t2)</tt> and in the list type <tt>t list a</tt>
--   represent the sets of locations the tuple or list may have been
--   created.
class Pretty a
pretty' :: Pretty a => Bool -> a -> String
prettyTS :: Pretty a => TyScheme a -> String
instance Pretty.Pretty a => Pretty.Pretty (Type.TyScheme a)
instance Pretty.Pretty Type.TyVar
instance Pretty.Pretty a => Pretty.Pretty (Type.Ty a)
instance Pretty.Pretty Type.FunId
instance Pretty.Pretty Type.Ann
instance Pretty.Pretty Type.AnnVar
instance Pretty.Pretty (Type.TyScheme Type.Ann, Type.Ann)
